Chapter 10 Ð Using Input and OutputConsole Input Using Character Streams* System.in = byte stream * To convert it to char stream, need to wrap it in the Reader* Console Reader class* Buffered Readero Supports buffered input streamo Can't be constructed directly from System.ino You must convert it into character stream with InputStreamReader = converts bytes to characterso Use constructor: InputStreamReader (InputStream inputStream)o System.in refers to the object of type InputStream, it can be used for inputStreamo Next using object produced by InputStreamReader, construct BufferedReader:* BufferedReader(Reader inputReader)o BufferedReader br = new BufferedReader(new InputStreamReader(System.in))* Converts byte stream to character stream and links it to buffered reader* br = character based stream that is linked to console through System.in* Reading Characters = read()o Buffered Reader has read(). Has 3 versions:* Int read() throws IOException* Reads unicode character* Returns -1 when attempt was made at the end of the stream* Int read(char data[]) throws IOException * Reads char from the input stream and puts into data[] until* Full* End of stream is reached * Error occurs* -1 when end of stream reached * Int read(char data[], int start, int max) throws IOException * Reads input into data[] begin at start until max characters are stored * -1 when end of the stream reached * All throw IOException on error * Reading Strings = readLine()o String readLine() throws IOExceptiono Returns String object o Null at the end of the stream ÊÊÊConsole Output Using Character Streams* System.out is permissable to use to write in the console, but recommended to use only foro Debugging purposeso Sample Programs* Real world programs preffered method is PrintWriter = character based * Character based classes makes it easier to internationalize your program * PrintWriter defines several constructorso PrintWriter(OutputStream outputStream, boolean flushingOn)* outputStream is object of OutputStream * flushingOn controls weather Java flushes the output stream every time println() method is called * If true = flushing automatically takes place * If false = flushing is not automatic * Supports print() and println() for all types including Object * Can be used the same way as System.out* If argument is not a primitive type* PrintWriter method calls the object's toString() method and then prints out the result* Console* Write using PrintWriter, speficy System.out for output stream and flush the stream after each call to println()* PrintWriter pw = new PrintWriter(System.out, true);* File I/O Using Character Streams* Byte oriented file handling is often most common * Advantage of character streams: o Operate directly on Unicode characters * To perform character-based file I/O, you eill use the FileReader and FileWriter classes.* FileWritero Creates a Writer to use to write to a file o 2 commonly used constructors:* FileWriter(String fileName) throws IOException * FileWriter(String fileName, boolean append) throws IOExceptiono fileName = path name of the file o If append = true, output is appened to the end of the file, if false = overwritten. o Derived from OutputStreamWriter, Writer can access methods of these classes* FileReadero Creates a Reader that you can use to read the contents of a file. o Commonlt used constructor:* FileReader(String fileName) throws FileNotFoundException * fileName = full path of the file o Derived from InputStreamReader, Reader can access methods of all of these classesÊÊType Wrappers to Convert Numeric Strings* Println() method automatically converts numeric values into their human readable form from bytes.* Read() method does not provide parallel functionality that reads and converts string containing numberic value into its internal, binary format. * Java privides Type Wrapperso Classes to encapsulate or wrap the primitive typeso Needed because primitive types are not objects and that limits their use to some extent:* Can't be passed by reference * Type wrapper clasees are: o Double* Static double parseDouble(Strinfgstr) throws NumberFormatExceptiono Float* Static float parseFloat(String str) throws NumberFormatExceptiono Long* Static long parseLong(String str) throws NumberFormatExceptiono Integer* Static int parseInt(String str) throws NumberFormatExceptiono Short* Static short parseShort(String str) throws NumberFormatExceptiono Byte * Static byte parseByte(String str) throws NumberFormatExceptiono Charactero Boolean * Offer wide array methods to integrate the primitive types into Java's object hirearchy.* Numeric wrappers define methods to convert a numeric string into its corresponding binary equivalent* Parsing methods give easy way to convert a numeric value which is read as a string from a keyboard or a text file, into its proper internal format.* Scanner o Reads formatted (human-radable) format and converts it into its binary formo Read input from variaety of sources:* Console* Files * Etc. o Can read numeric values enetered by keyboard and assign its value to a variable.o To read from keyboard link it to console input: Scanner(InputStream from)* Creates Scannertthat uses stream specified by from* Scanner consoleInput = new Scanner(System.in);* Works, because System.in = InputStream* consoleInput can be used to read input from keyboard * Procedure:1. Determine if specific type of input is available by one of the Scanner's hasNextX methods, where X is the type of data desired.2. If input is avialble, read it by calling one of Scanner's nextX methodso Defines 2 sets of methods that enable to read input * hasNext * hasNextInt() returns true only if* Next item in the stream is the human readable form of an interger. * hasNextDouble() * Etc. * Return true if desired data type is next avaialble item in the data stream and false otherwise  Next methods* nextInt()* nextDouble()* Convert the human radable form of the data into its internal, binary represenation and returns result. o Scanner conin = new Scanner(System.in);Int i;If (comin.hasNextInt()) I = conin.nextInt();o Usually both methods need to be used togethero If next can't find the type it is looking for throws InputMismatchException